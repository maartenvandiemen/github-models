name: AI Issue Triage

on:
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write
  models: read

env:
  MODEL: openai/gpt-4o-mini
  READY_LABEL: ready-for-dev
  TRIAGED_LABEL: triaged
  NEEDS_INFO_LABEL: needs-more-info
  AI_LABEL: ai-triage

jobs:
  triage:
    if: ${{ !contains(github.event.issue.labels.*.name, 'no-ai-triage') }}
    runs-on: ubuntu-latest
    concurrency:
      group: issue-ai-triage-${{ github.event.issue.number }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Prepare inputs
        id: prep
        shell: bash
        run: |
          title=$(jq -r '.issue.title // ""' "$GITHUB_EVENT_PATH")
          printf "title=%s\n" "$title" >> "$GITHUB_OUTPUT"
          jq -r '.issue.body // ""' "$GITHUB_EVENT_PATH" > issue_body.txt

      - name: Run AI inference with prompt file
        id: ai
        uses: actions/ai-inference@v1
        with:
          model: ${{ env.MODEL }}
          prompt-file: .github/prompts/issue-triage.prompt.yml
          input: |
            title: ${{ steps.prep.outputs.title }}
          file_input: |
            body: issue_body.txt
          max-tokens: 1000

      - name: Save and validate AI JSON
        id: parse
        env:
          AI_CONTENT: ${{ steps.ai.outputs.content }}
          AI_RESPONSE: ${{ steps.ai.outputs.response }}
        shell: bash
        run: |
          #!/usr/bin/env bash
          set -euo pipefail

          content="${AI_CONTENT:-}"

          # If content is empty/null, try to extract from the raw response using multiple schemas.
          if [ -z "${content}" ] || [ "${content}" = "null" ]; then
            content="$(jq -r '
                # OpenAI Responses API: concatenated text
                .output_text
                # Or explicit output content array
                // (.output[0].content[]? | select(.type=="output_text") | .text)
                # Legacy Chat Completions
                // .choices[0].message.content
                // .choices[0].text
                # Some providers (Gemini-style)
                // (.candidates[0].content.parts[]? | .text)
                # Nothing matched
                // empty
              ' <<< "${AI_RESPONSE:-}" 2>/dev/null || echo "")"
          fi

          # Strip optional Markdown code fences if they wrap the entire output
          if [ -n "${content}" ]; then
            # Check if content starts with ```json or ``` and ends with ```
            first_line="$(printf "%s" "$content" | head -n1)"
            last_line="$(printf "%s" "$content" | tail -n1)"
            if [[ "$first_line" =~ ^\`\`\`(json)?[[:space:]]*$ ]] && [[ "$last_line" =~ ^\`\`\`[[:space:]]*$ ]]; then
              content="$(printf "%s" "$content" | sed '1d;$d')"
            fi
          fi

          # If still empty, synthesize a safe default
          if [ -z "${content}" ]; then
            content='{
              "actionable": false,
              "summary": "AI triage could not parse a valid response.",
              "missing": ["reproduction steps", "expected vs actual", "environment details"],
              "questions": ["Please provide the missing details listed above."],
              "labels": ["needs-more-info"],
              "confidence": 0
            }'
          fi

          # Write and validate JSON
          printf "%s" "$content" > ai.json

          # If validation fails (e.g., stray text), try a last-chance extraction of the first JSON object/array
          if ! jq . ai.json >/dev/null 2>&1; then
            # Try to extract JSON using a simple approach with sed and grep
            extracted=""
            
            # Look for first JSON object
            if grep -q '{' ai.json; then
              # Extract content between first { and its matching }
              extracted="$(awk '
                BEGIN { brace_count=0; collecting=0; result="" }
                {
                  for (i=1; i<=length($0); i++) {
                    char = substr($0, i, 1)
                    if (char == "{") {
                      if (brace_count == 0) collecting = 1
                      brace_count++
                    }
                    if (collecting) result = result char
                    if (char == "}") {
                      brace_count--
                      if (brace_count == 0 && collecting) {
                        print result
                        exit
                      }
                    }
                  }
                }
              ' ai.json)"
            fi
            
            # If no object found, look for JSON array
            if [ -z "$extracted" ] && grep -q '\[' ai.json; then
              extracted="$(awk '
                BEGIN { bracket_count=0; collecting=0; result="" }
                {
                  for (i=1; i<=length($0); i++) {
                    char = substr($0, i, 1)
                    if (char == "[") {
                      if (bracket_count == 0) collecting = 1
                      bracket_count++
                    }
                    if (collecting) result = result char
                    if (char == "]") {
                      bracket_count--
                      if (bracket_count == 0 && collecting) {
                        print result
                        exit
                      }
                    }
                  }
                }
              ' ai.json)"
            fi

            if [ -n "${extracted}" ]; then
              printf "%s" "$extracted" > ai.json
            else
              # Final fallback to safe default
              printf '{
                "actionable": false,
                "summary": "AI triage could not parse a valid response.",
                "missing": ["reproduction steps", "expected vs actual", "environment details"],
                "questions": ["Please provide the missing details listed above."],
                "labels": ["needs-more-info"],
                "confidence": 0
              }' > ai.json
            fi
          fi

          # Final validation and output
          jq . ai.json >/dev/null
          echo "ai=$(jq -c . ai.json)" >> "$GITHUB_OUTPUT"

      - name: Sync labels
        if: success()
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}
          if [ -z "${AI:-}" ] || [ "${AI}" = "null" ]; then
            echo "AI output missing; adding ${NEEDS_INFO_LABEL}/${AI_LABEL}."
            gh issue edit "$number" --add-label "${NEEDS_INFO_LABEL}" || true
            gh issue edit "$number" --add-label "${AI_LABEL}" || true
            exit 0
          fi

          actionable=$(jq -r '.actionable // false' <<< "$AI")

          declare -a add_labels=()
          if [ "$actionable" = "true" ]; then
            add_labels+=("${READY_LABEL}" "${TRIAGED_LABEL}")
          else
            add_labels+=("${NEEDS_INFO_LABEL}" "${AI_LABEL}")
          fi

          mapfile -t suggested < <(jq -r '.labels // [] | .[]' <<< "$AI")
          for l in "${suggested[@]}"; do
            [ -n "$l" ] && add_labels+=("$l")
          done

          for l in "${add_labels[@]}"; do
            gh issue edit "$number" --add-label "$l" || true
          done

          if [ "$actionable" = "true" ]; then
            gh issue edit "$number" --remove-label "${NEEDS_INFO_LABEL}" || true
          else
            gh issue edit "$number" --remove-label "${READY_LABEL}" || true
          fi

      - name: Comment with questions when not actionable
        if: success() && fromJson(steps.parse.outputs.ai).actionable == false
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}
          summary=$(jq -r '.summary' <<< "$AI")
          mapfile -t missing < <(jq -r '.missing[]?' <<< "$AI")
          mapfile -t questions < <(jq -r '.questions[]?' <<< "$AI")

          {
            echo "Thanks for opening this issue! I ran an automated triage to help our maintainers."
            echo
            echo "Summary:"
            echo "$summary"
            echo
            if [ "${#missing[@]}" -gt 0 ]; then
              echo "To help a developer pick this up, please provide:"
              for m in "${missing[@]}"; do
                echo "- $m"
              done
              echo
            fi
            if [ "${#questions[@]}" -gt 0 ]; then
              echo "Follow-up questions:"
              for q in "${questions[@]}"; do
                echo "- $q"
              done
              echo
            fi
            echo "Once you've updated the issue, reply here and the bot will re-check. To bypass, a maintainer can add the \"${{ env.READY_LABEL }}\" label."
          } > comment.md

          gh issue comment "$number" -F comment.md

      - name: Confirm ready-for-dev
        if: success() && fromJson(steps.parse.outputs.ai).actionable == true
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}
          summary=$(jq -r '.summary' <<< "$AI")
          gh issue comment "$number" --body "$(printf "AI triage summary: %s\n\nLabeling as %s." "$summary" "${{ env.READY_LABEL }}")"
