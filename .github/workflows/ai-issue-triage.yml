name: AI Issue Triage

on:
  issues:
    types: [opened, edited]

permissions:
  contents: read
  issues: write
  models: read

env:
  MODEL: openai/gpt-4o-mini
  READY_LABEL: ready-for-dev
  TRIAGED_LABEL: triaged
  NEEDS_INFO_LABEL: needs-more-info
  AI_LABEL: ai-triage

jobs:
  triage:
    if: ${{ !contains(github.event.issue.labels.*.name, 'no-ai-triage') }}
    runs-on: ubuntu-latest
    concurrency:
      group: issue-ai-triage-${{ github.event.issue.number }}
      cancel-in-progress: true
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare inputs
        id: prep
        shell: bash
        run: |
          title=$(jq -r '.issue.title // ""' "$GITHUB_EVENT_PATH")
          printf "title=%s\n" "$title" >> "$GITHUB_OUTPUT"
          jq -r '.issue.body // ""' "$GITHUB_EVENT_PATH" > issue_body.txt

      - name: Run AI inference with prompt file
        id: ai
        uses: actions/ai-inference@v1
        with:
          model: ${{ env.MODEL }}
          prompt-file: .github/prompts/issue-triage.prompt.yml
          input: |
            title: ${{ steps.prep.outputs.title }}
          file_input: |
            body: issue_body.txt
          max-tokens: 1000

      - name: Save and validate AI JSON
        id: parse
        env:
          AI_CONTENT: ${{ steps.ai.outputs.content }}
          AI_RESPONSE: ${{ steps.ai.outputs.response }}
        shell: bash
        run: |
          set -euo pipefail

          # Prefer the action's 'content' output; fall back to parsing the raw response
          content="${AI_CONTENT:-}"
          if [ -z "$content" ] || [ "$content" = "null" ]; then
            content="$(jq -r '.choices[0].message.content // empty' <<< "${AI_RESPONSE:-}" || echo "")"
          fi

          # If still empty, emit a safe default that matches our schema so downstream steps work
          if [ -z "$content" ]; then
            content='{
              "actionable": false,
              "summary": "AI triage could not parse a valid response.",
              "missing": ["reproduction steps", "expected vs actual", "environment details"],
              "questions": ["Please provide the missing details listed above."],
              "labels": ["needs-more-info"],
              "confidence": 0
            }'
          fi

          # Validate and compact to a single line for $GITHUB_OUTPUT
          printf "%s" "$content" > ai.json
          jq . ai.json >/dev/null
          ai_compact="$(jq -c . ai.json)"

          echo "ai=$ai_compact" >> "$GITHUB_OUTPUT"

      - name: Sync labels
        if: success()
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}

          if [ -z "${AI:-}" ] || [ "${AI}" = "null" ]; then
            echo "AI output missing; adding ${NEEDS_INFO_LABEL}/${AI_LABEL}."
            gh issue edit "$number" --add-label "${NEEDS_INFO_LABEL}" || true
            gh issue edit "$number" --add-label "${AI_LABEL}" || true
            exit 0
          fi

          actionable=$(jq -r '.actionable // false' <<< "$AI")

          declare -a add_labels=()
          if [ "$actionable" = "true" ]; then
            add_labels+=("${READY_LABEL}" "${TRIAGED_LABEL}")
          else
            add_labels+=("${NEEDS_INFO_LABEL}" "${AI_LABEL}")
          fi

          mapfile -t suggested < <(jq -r '.labels // [] | .[]' <<< "$AI")
          for l in "${suggested[@]}"; do
            [ -n "$l" ] && add_labels+=("$l")
          done

          for l in "${add_labels[@]}"; do
            gh issue edit "$number" --add-label "$l" || true
          done

          if [ "$actionable" = "true" ]; then
            gh issue edit "$number" --remove-label "${NEEDS_INFO_LABEL}" || true
          else
            gh issue edit "$number" --remove-label "${READY_LABEL}" || true
          fi

      - name: Comment with questions when not actionable
        if: success() && fromJson(steps.parse.outputs.ai).actionable == false
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}
          summary=$(jq -r '.summary' <<< "$AI")
          mapfile -t missing < <(jq -r '.missing[]?' <<< "$AI")
          mapfile -t questions < <(jq -r '.questions[]?' <<< "$AI")

          {
            echo "Thanks for opening this issue! I ran an automated triage to help our maintainers."
            echo
            echo "Summary:"
            echo "$summary"
            echo
            if [ "${#missing[@]}" -gt 0 ]; then
              echo "To help a developer pick this up, please provide:"
              for m in "${missing[@]}"; do
                echo "- $m"
              done
              echo
            fi
            if [ "${#questions[@]}" -gt 0 ]; then
              echo "Follow-up questions:"
              for q in "${questions[@]}"; do
                echo "- $q"
              done
              echo
            fi
            echo "Once you've updated the issue, reply here and the bot will re-check. To bypass, a maintainer can add the \"${{ env.READY_LABEL }}\" label."
          } > comment.md

          gh issue comment "$number" -F comment.md

      - name: Confirm ready-for-dev
        if: success() && fromJson(steps.parse.outputs.ai).actionable == true
        env:
          AI: ${{ steps.parse.outputs.ai }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        shell: bash
        run: |
          number=${{ github.event.issue.number }}
          summary=$(jq -r '.summary' <<< "$AI")
          gh issue comment "$number" --body "$(printf "AI triage summary: %s\n\nLabeling as %s." "$summary" "${{ env.READY_LABEL }}")"
